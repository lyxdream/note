
# 模块化规范

## CommonJs规范

https://www.jianshu.com/p/25d605cb7edf

https://www.jianshu.com/p/c38e19cda77c

https://zhuanlan.zhihu.com/p/395504491

https://www.jianshu.com/p/296446c457c2

https://es6.ruanyifeng.com/#docs/module

https://blog.csdn.net/qq_38974163/article/details/120078340

https://blog.csdn.net/aa494661239/article/details/119454669

https://www.jianshu.com/p/9c4095d4aa59




## AMD规范

AMD规范是通过Require.js实现的，所以需要下载Require.js文件。

## CMD规范

### 定义

- CMD（Common Module Definition）通用模块定义。
- CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。Sea.js 遵循 CMD 规范

### 规范基本语法

```
使用：define(function(require,exports,module){})
导出：define(function(require){return 值})

常用api:define, require, require.async, exports, module.exports

```
- 定义暴露模块

```
//定义没有依赖的模块
define(function(require, exports, module){
  exports.xxx = value
  module.exports = value
})
```
```
//定义有依赖的模块
define(function(require, exports, module){
  //引入依赖模块(同步)
  var module2 = require('./module2')
  //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
  //暴露模块
  exports.xxx = value
})
```
- 引入使用模块

```
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```
- require.async(id, callback?)
require.async 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。callback 参数可选。

```
define(function(require, exports, module) {

  // 异步加载一个模块，在加载完成时，执行回调
  require.async('./b', function(b) {
    b.doSomething();
  });

  // 异步加载多个模块，在加载完成时，执行回调
  require.async(['./c', './d'], function(c, d) {
    c.doSomething();
    d.doSomething();
  });

});
```

> 注意：require 是同步往下执行，require.async 则是异步回调执行。require.async 一般用来加载可延迟异步加载的模块。

### sea.js简单使用教程

1. 下载sea.js, 并引入

官网: https://seajs.github.io/seajs/docs/#docs
github : https://github.com/seajs/seajs
CMD 模块定义规范:https://github.com/seajs/seajs/issues/242
Sea.js的使用示例：https://github.com/seajs/examples

```js
<script src="./sea-modules/sea.js"></script>
```

2. 在 hello.html 页尾，通过 script 引入 sea.js 后，有一段配置代码：

```
// seajs 的简单配置
seajs.config({
  base: "../sea-modules/",
  alias: {
    "jquery": "jquery/jquery/1.10.1/jquery.js"
  }
})

// 加载入口模块
seajs.use("./main")
```
sea.js 在下载完成后，会自动加载入口模块。

3. 模块代码

```js
define(function(require) {

  var Spinning = require('./spinning');  //加载spinning模块

  var s = new Spinning('#container');
  s.render();

});
```


### CMD和AMD区别

> 对比CMD和AMD可以发现，AMD的依赖是前置的，在一个数组里头，直接就先加载了再执行后面的代码，而CMD的依赖是后置的，只有需要的时候，才会去执行模块的加载。




## UMD规范

## ES6模块机制


## 模块化规范的优点

- 可以抽离公共的代码，避免重复的复制粘贴
- 可以隔离作用域，避免变量的冲突
- 可以将一个复杂的系统分解为多个子模块，便于开发和维护














format：输出的文件可以还可以是 amd，umd，cjs，es，iife；

cjs，amd，umd，es，iife 区别：

cjs:

- 只能在 NodeJS 上运行，使用 require("module") 读取并加载模块。
- commonjs 导入模块是同步导入
- 主要用于后端，客户端用的话需要通过 Browserify
- 缺点：不支持浏览器，执行后才能拿到依赖信息，由于用户可以动态 require（例如 react 根据开发和生产环境导出不同代码 的写法），无法做到提前分析依赖以及 Tree-Shaking 。

amd:

- Asynchronous Module Definition，可以看作 CJS 的异步版本，制定了一套规则使模块可以被异步 require 进来并在回调函数里继续使用
- 其适用于浏览器端

umd: (Universal Module Definition)

- 其是 amd 和 commonjs 的统一规范，支持两种规范，即写一套代码，可用于多种场景
- 支持直接在前端用 <script src="lib.umd.js"></script> 的方式加载
- 前后端均通用
- 与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。
- UMD 在使用诸如 Rollup/ Webpack 之类的 bundler 时通常用作备用模块

IIFE:

- Immediately Invoked Function Expression，只是一种写法，可以隐藏一些局部变量

ESM：ESM 是 ES6 提出的标准模块系统

- ESM 格式被设计为可以被静态分析，打包器可以轻易做到分析依赖以及 Tree-Shaking,也支持动态加载（import()）。
- 现代浏览器中通过 <script type="module"> 直接导入
- 使用 import export 来管理依赖
- node 也开始支持
  > node 支持 ESModule node 最新版本进一步增强了对 ESModule 的支出，只需要在 package.json 增加一个选项即可 "type":"module"
- 很多浏览器开始支持
