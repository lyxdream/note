
# 模块化规范


## 模块化的形成过程：
### 模块化出现的背景：

1. 定义全局function的方式，会出现函数命名污染的情况。

2. 在命名空间（name space）中定义方法，定义一个obj = {function1() {},function2(){}};这样有个问题就是函数内部的成员可以被随意修改，很不安全

3. 通过IIFE（Immediately Invoked Function Expression）模式（自执行函数），也就是函数自调用闭包的方式，暴露给window
创建的时候就直接执行，然后返回一个参数对象对象中可以有方法，属性等，然后再外部进行调用

```js
//创建自执行函数
var testUtils = function () {
    function test(data){
        console.log(data)
    }
    return {
      test
    }
}();
//执行自执行函数中的方法
testUtils.test("yx")
//张三
```
4. IIFE增强模式：引入依赖。为了解决上面的问题，就出现了IIFE增强模式，就是传参把其他的模块给传进去，就出现了先后顺序很重要的问题，如果前面的都还没挂载到window上面，此时运行后面的js代码肯定就是undefined。

优点
1. 不会污染全局，也不会被外部更改
IIFE模式的缺点：
1. 必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用
2. 代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写
3. 在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况

## 采用模块化规范的原因：
- 可以隔离作用域：避免变量命名的冲突，避免命名污染
- 提高代码的复用性：可以抽离公共的代码，避免重复的复制粘贴
- 更好的分离代码，实现按需加载
- 提升代码的维护性：可以将一个复杂的系统分解为多个子模块，便于开发和维护

**四种常用的模块化规范**

> commonJS,AMD,CMD,UMD,ES6模块机制
## CommonJs规范

### 概述



### 特点

- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。
- 因为被输出的是拷贝值，则如果在外部对模块代码就行修改则不会生效
- 在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。
- Node是CommonJS在服务器端一个具有代表性的实现,Browserify是CommonJS在浏览器中的一种实现

### 规范基本用法

```
暴露模块：module.exports = value或 exports.xxx = value

引入模块：require(xxx),如果是第三方模块，xxx为模块名；如果是自定义模块，xxx为模块文件路径

CommonJS规范的核心变量：exports、module.exports、require；
```


**exports和module.exports区别和联系：**
  - module对象的exports属性是exports对象的一个引用
  - module.exports = exports
  - 默认modules.exports和exports指向同一个引用地址
  - 但是实际上require(x)方法导出的时候，是找到匹配x的文件，导出当前文件中的modules.exports对象

## AMD规范

### 概述

- AMD（Asynchronous Module Definition) 异步模块定义

### 特点

- AMD是专门用于浏览器端的，模块的加载是异步的,Require.js实现了AMD规范
- 依赖是前置的，先加载了依赖,再执行后面的代码

### 规范基本用法

```js
导出：define(['module1'], function(m1){
   return 模块
})
使用：require(['module1'], function(m1, m2){
   //使用m1
})
```
- 定义暴露模块:

```js
//定义没有依赖的模块
define(function(){
   return 模块
})

//定义有依赖的模块
define(['module1', 'module2'], function(m1, m2){
   return 模块
})
```
- 引入使用模块:

```js
require(['module1', 'module2'], function(m1, m2){
   使用m1/m2
})
```

### require.js的简单使用教程

> RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。

1. 下载require.js，找到其中的require.js文件

- github：https://github.com/requirejs/requirejs
- 官网：https://requirejs.org

2. 引入require.js和定义入口文件：

```js
//index.html
<script src="./src/require.js" data-main="./index.js"></script>
```
> data-main属性的作用是在加载完src的文件后会加载执行该文件

3. 定义require.js的模块代码

```js
//index.js
//配置模块及其路径
require.config({
  baseUrl: "./src", //默认为当前文件所在目录
  paths: {
    foo: "./foo"
  },
});

//使用模块
require(["foo"], function (foo) {
  console.log(foo.name, foo.age);
});

```
```js
//src/foo.js
define(function () {
  const name = "yx";
  const age = 18;

  //导出变量
  return {
    name,
    age,
  }
});
```
打开index.html文件，在浏览器控制台可以看到以下打印结果：

```js
{name: "yx", age: 18}
```

### AMD和common.js区别

- CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。
- 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。
- 如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。
- AMD规范比CommonJS规范在浏览器端实现的早

## CMD规范

### 概述

- CMD（Common Module Definition）通用模块定义。

### 特点

- CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。Sea.js 遵循 CMD 规范
- CMD推崇就近依赖，所以不在define的参数中写依赖，而在factory中写

### 规范基本用法

```
导出：define(function(require,exports,module){
  exports.xxx = value
  module.exports = value
})
使用：define(function(require,exports,module){})

常用api:define, require, require.async, exports, module.exports

```
- 定义暴露模块

```js
//定义没有依赖的模块
define(function(require, exports, module){
  exports.xxx = value
  module.exports = value
})
```
```js
//定义有依赖的模块
define(function(require, exports, module){
  //引入依赖模块(同步)
  var module2 = require('./module2')
  //引入依赖模块(异步)
    require.async('./module3', function (m3) {
    })
  //暴露模块
  exports.xxx = value
})
```
- 引入使用模块

```js
define(function (require) {
  var m1 = require('./module1')
  var m4 = require('./module4')
  m1.show()
  m4.show()
})
```
- require.async(id, callback?)
require.async 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。callback 参数可选。

```js
define(function(require, exports, module) {

  // 异步加载一个模块，在加载完成时，执行回调
  require.async('./b', function(b) {
    b.doSomething();
  });

  // 异步加载多个模块，在加载完成时，执行回调
  require.async(['./c', './d'], function(c, d) {
    c.doSomething();
    d.doSomething();
  });

});
```

> 注意：require 是同步往下执行，require.async 则是异步回调执行。require.async 一般用来加载可延迟异步加载的模块。

### sea.js简单使用教程

1. 下载sea.js, 找到dist文件夹下的sea.js，并引入

官网: https://seajs.github.io/seajs/docs/#docs
github : https://github.com/seajs/seajs

CMD 模块定义规范:https://github.com/seajs/seajs/issues/242
Sea.js的使用示例：https://github.com/seajs/examples

```js
<script src="./src/sea.js"></script>
```

2. 在 index.html 页尾，通过 script 引入 sea.js 后，指定主入口文件:

```html
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="./lib/sea.js" ></script>
    <script>
     //加载入口模块
      seajs.use('./src/index.js')
    </script>
  </body>
</html>

```
sea.js 在下载完成后，会自动加载入口模块。

3. 模块代码

```js
//./src/index.js
define(function(require,exports,module){
   //导入foo模块
   const foo = require('./foo')
   console.log(foo)
})
```
```js
//./src/foo.js
define(function (require, exports, module) {
  const name = "yx";
  const age = 18;

  //导出变量
  module.exports = {
    name,
    age,
  };
});
```

打开index.html文件，在浏览器控制台可以看到以下打印结果：

```js
{name: "yx", age: 18}
```

### CMD和AMD区别

> 对比CMD和AMD可以发现，AMD的依赖是前置的，在一个数组里头，直接就先加载了再执行后面的代码，而CMD的依赖是后置的，只有需要的时候，才会去执行模块的加载。


## UMD规范

### 概述

- UMD (Universal Module Definition)通用模块定义

### 特点
- 前后端均通用
- 是 amd 和 commonjs 的统一规范，支持两种规范，即写一套代码，可用于多种场景
- 跟CJS，AMD不同的是，UMD更像是一种模式，去适配多种模块系统。
- 当用像rollup/webpack这样的打包器的时候，UMD通常用作一个回调模块。

### 规范基本用法

- github：https://github.com/umdjs/umd

-  支持直接在前端用 <script src="xxx.js"></script> 的方式加载

```js
// 定义一个在 Node、AMD 和浏览器全局变量中工作的模块。

(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. 注册一个匿名的模块
        define(['b'], factory);
    } else if (typeof module === 'object' && module.exports) {
       //不适用于严格的 CommonJS，但是仅支持 module.exports 的类 CommonJS 环境
        module.exports = factory(require('b'));
    } else {
        //  浏览器全局变量 (root 指 window)
        root.returnExports = factory(root.b);
    }
}(typeof self !== 'undefined' ? self : this, function (b) {
    // 只需返回一个值来定义模块导出，可以返回一个函数作为导出值.
    return {};
}));
```

## ES6模块机制

- 它兼具两方面的优点：具有 CJS 的简单语法和 AMD 的异步
- 得益于 ES6 的静态模块结构，可以进行 Tree Shaking
- ESM 允许像 Rollup 这样的打包器，删除不必要的代码，减少代码包可以获得更快的加载

- 他最大的特点是按需加载。

```
通过export或者export default来导出：

export 只支持对象形式的导出，不支持值导出
export default用于指定指定模块的默认导出，只支持值导出

```











format：输出的文件可以还可以是 amd，umd，cjs，es，iife；

cjs，amd，umd，es，iife 区别：

cjs:

- 只能在 NodeJS 上运行，使用 require("module") 读取并加载模块。
- commonjs 导入模块是同步导入
- 主要用于后端，客户端用的话需要通过 Browserify
- 缺点：不支持浏览器，执行后才能拿到依赖信息，由于用户可以动态 require（例如 react 根据开发和生产环境导出不同代码 的写法），无法做到提前分析依赖以及 Tree-Shaking 。

amd:

- Asynchronous Module Definition，可以看作 CJS 的异步版本，制定了一套规则使模块可以被异步 require 进来并在回调函数里继续使用
- 其适用于浏览器端

umd: (Universal Module Definition)

- 其是 amd 和 commonjs 的统一规范，支持两种规范，即写一套代码，可用于多种场景
- 支持直接在前端用 <script src="lib.umd.js"></script> 的方式加载
- 前后端均通用
- 与 CJS 或 AMD 不同，UMD 更像是一种配置多个模块系统的模式。
- UMD 在使用诸如 Rollup/ Webpack 之类的 bundler 时通常用作备用模块

IIFE:

- Immediately Invoked Function Expression，只是一种写法，可以隐藏一些局部变量

ESM：ESM 是 ES6 提出的标准模块系统

- ESM 格式被设计为可以被静态分析，打包器可以轻易做到分析依赖以及 Tree-Shaking,也支持动态加载（import()）。
- 现代浏览器中通过 <script type="module"> 直接导入
- 使用 import export 来管理依赖
- node 也开始支持
  > node 支持 ESModule node 最新版本进一步增强了对 ESModule 的支出，只需要在 package.json 增加一个选项即可 "type":"module"
- 很多浏览器开始支持
