# 基础知识

## 第1章 面向对象的javaScript
### 1. 动态类型语言和鸭子类型

编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。

静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。

动态类型语言的缺点是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。

鸭子类型:这一切都建立在鸭子类型（duck typing）的概念上，鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”
鸭子类型指导我们只关注对象的行为，而不关注对象本身，也就是关注HAS-A，而不是IS-A。

利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”

### 2. 多态
多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。

多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。

instanceof 是 JavaScript 的一个运算符，用于检查一个对象是否是某个特定类的实例。
```js
object instanceof class
```
其中，object 是要检查的对象，class 是要检查的类或构造函数。
使用 instanceof 运算符可以判断一个对象是否是某个类的实例，或者是该类的派生类的实例。它会返回一个布尔值，表示对象是否是指定类或其派生类的实例。
换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。
将行为分布在各个对象中，并让这些对象各自负责自己的行为，这正是面向对象设计的优点。

首先我们把不变的部分隔离出来，然后把可变的部分各自封装起来，

### 3. 封装
找到变化并封装之
创建型模式的目的就是封装创建对象的变化。而结构型模式封装的是对象之间的组合关系。行为型模式封装的是对象的行为变化。
系统中稳定不变的部分和容易变化的部分隔离开来,在系统的演变过程中，我们只需要替换那些容易变化的部分
当我们想办法把程序中变化的部分封装好之后，剩下的即是稳定而可复用的部分了。

### 4.原型模式和基于原型继承的javaScript对象系统
在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。
而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。
- 使用克隆的原型模式
ECMAScript 5提供了Object.create方法，可以用来克隆对象。

> 通过设置构造器的prototype来实现原型继承的时候，除了根对象Object.prototype本身之外，任何对象都会有一个原型。而通过Object.create( null )可以创建出没有原型的对象。

在JavaScript语言中不存在类的概念，对象也并非从类中创建出来的，所有的JavaScript对象都是从某个对象上克隆而来的。

Object是Animal的原型，而Animal是Dog的原型，它们之间形成了一条原型链。这个原型链是很有用处的，当我们尝试调用Dog对象的某个方法时，而它本身却没有这个方法，那么Dog对象会把这个请求委托给它的原型Animal对象，如果Animal对象也没有这个属性，那么请求会顺着原型链继续被委托给Animal对象的原型Object对象，这样一来便能得到继承的效果，看起来就像Animal是Dog的“父类”, Object是Animal的“父类”。

基于原型链的委托机制就是原型继承的本质。

- 所有的数据都是对象。
- 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
  - 对象会记住它的原型。
  - 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。

1．所有的数据都是对象
事实上，JavaScript中的根对象是Object.prototype对象。Object.prototype对象是一个空的对象。

2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它

```js
  function Person( name ){
      this.name = name;
  };

  Person.prototype.getName = function(){
      return this.name;
  };

  const a = new Person( 'sven' )

  console.log( a.name );    // 输出：sven
  console.log( a.getName() );     // 输出：sven
  console.log( Object.getPrototypeOf( a ) === Person.prototype );     // 输出：true
```
在这里Person并不是类，而是函数构造器，JavaScript的函数既可以作为普通函数被调用，也可以作为构造器被调用。
当使用new运算符来调用函数时，此时的函数就是一个构造器。
用new运算符来创建对象的过程，实际上也只是先克隆Object.prototype对象，再进行一些其他额外操作的过程。

```js
  function Person( name ){
      this.name = name;
  };

  Person.prototype.getName = function(){
      return this.name;
  };

  const objectFactory = function(){
      const obj = new Object(),    // 从Object.prototype上克隆一个空的对象
        Constructor = [].shift.call( arguments );    // 取得外部传入的构造器，此例是Person
       obj.__proto__ = Constructor.prototype;    // 指向正确的原型
      const ret = Constructor.apply( obj, arguments );    // 借用外部传入的构造器给obj设置属性

      return typeof ret === 'object' ? ret : obj;     // 确保构造器总是会返回一个对象
  };

  const a = objectFactory( Person, 'sven' );
  console.log( a.name );    // 输出：sven
  console.log( a.getName() );     // 输出：sven
  console.log( Object.getPrototypeOf( a ) === Person.prototype );      // 输出：true

```
3. 对象会记住它的原型

就JavaScript的真正实现来说，其实并不能说对象有原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好的说法是对象把请求委托给它的构造器的原型。

JavaScript给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指向它的构造器的原型对象，即{Constructor}.prototype。

```js
  const a = new Object();
  console.log ( a.__proto__=== Object.prototype );    // 输出：true
```
实际上，__proto__就是对象跟“对象构造器的原型”联系起来的纽带。

4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型

而在JavaScript中，每个对象都是从Object.prototype对象克隆而来的
- 当对象a需要借用对象b的能力时，可以有选择性地把对象a的构造器的原型指向对象b，从而达到继承的效果。

```js
  let obj = { name: 'sven' };
  let A = function(){};
  A.prototype = obj;
  let a = new A();
  console.log( a.name );    // 输出：sven
```
我们来看看执行这段代码的时候，引擎做了哪些事情。
❏ 首先，尝试遍历对象a中的所有属性，但没有找到name这个属性。
❏ 查找name属性的这个请求被委托给对象a的构造器的原型，它被a.__proto__ 记录着并且指向A.prototype，而A.prototype被设置为对象obj。
❏ 在对象obj中找到了name属性，并返回它的值。

- 当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现：

```js
  const A = function(){};
  A.prototype = { name: 'sven' };

  const B = function(){};
  B.prototype = new A();

  const b = new B();
  console.log( b.name );    // 输出：sven

```
再看这段代码执行的时候，引擎做了什么事情。
❏ 首先，尝试遍历对象b中的所有属性，但没有找到name这个属性。
❏ 查找name属性的请求被委托给对象b的构造器的原型，它被b.__proto__记录着并且指向B.prototype，而B.prototype被设置为一个通过new A()创建出来的对象。
❏ 在该对象中依然没有找到name属性，于是请求被继续委托给这个对象构造器的原型A.prototype。
❏ 在A.prototype中找到了name属性，并返回它的值。

都是将对象构造器的原型指向另外一个对象，继承总是发生在对象和对象之间。

最后还要留意一点，原型链并不是无限长的

实际上，当请求达到A.prototype，并且在A.prototype中也没有找到address属性的时候，请求会被传递给A.prototype的构造器原型Object.prototype，显然Object.prototype中也没有address属性，但Object.prototype的原型是null，说明这时候原型链的后面已经没有别的节点了。所以该次请求就到此打住，a.address返回undefined。

## 第2章 this、call和apply
### 1.this
JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。
this的指向大致可以分为以下4种。
 - 作为对象的方法调用。
 - 作为普通函数调用。
 - 构造器调用。
 - Function.prototype.call或Function.prototype.apply调用。

1．作为对象的方法调用
当函数作为对象的方法被调用时，this指向该对象：

```js
  const obj = {
      a: 1,
      getA: function(){
        alert ( this === obj );    // 输出：true
        alert ( this.a );    // 输出： 1
      }
  };
  obj.getA();
```
2．作为普通函数调用

此时的this总是指向全局对象。在浏览器的JavaScript里，这个全局对象是window对象。
```js
  window.name = 'globalName';
  const getName = function(){
      return this.name;
  };
  console.log( getName() );    // 输出：globalName
```

<!-- 或者 -->

```js
  window.name = 'globalName';

  const myObject = {
      name: 'sven',
      getName: function(){
        return this.name;
      }
  };

  const getName = myObject.getName;
  console.log( getName() );    // globalName
```

3．构造器调用
构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。
> 当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象

```js
const MyClass = function(){
    this.name = 'sven';
};
const obj = new MyClass();
alert ( obj.name );     // 输出：sven
```
> 但用new调用构造器时，还要注意一个问题，如果构造器显式地返回了一个object类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this：

```js
const MyClass = function(){
  this.name = 'sven'
  return {
    name:"anne"
  }
}
const obj = new MyClass();
console.log(obj.name)  //anne
```
> 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题：
```js
const MyClass = function(){
  this.name = 'sven'
  return "anne"
}
const obj = new MyClass();
console.log(obj.name)  //sven
```
4. Function.prototype.call或Function.prototype.apply调用

> 跟普通的函数调用相比，用Function.prototype.call或Function.prototype.apply可以动态地改变传入函数的this：

```js
  const obj1 = {
      name: 'sven',
      getName: function(){
        return this.name;
      }
  };

  const obj2 = {
      name: 'anne'
  };

  console.log( obj1.getName() );     // 输出： sven
  console.log( obj1.getName.call( obj2 ) );    // 输出：anne
```
### 2. call和apply

1. call和apply的区别

> apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数：
```js
  const func = function( a, b, c ){
      alert ( [ a, b, c ] );    // 输出 [ 1, 2, 3 ]
  };
  func.apply( null, [ 1, 2, 3 ] );
//在这段代码中，参数1、2、3被放在数组中一起传入func函数，它们分别对应func参数列表中的a、b、c。
```
> call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数：

```js
const func = function( a, b, c ){
    alert ( [ a, b, c ] );    // 输出 [ 1, 2, 3 ]
};
func.call( null, 1, 2, 3 );
```
> 当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window：

有时候我们使用call或者apply的目的不在于指定this指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入null来代替某个具体的对象：

```js
Math.max.apply( null, [ 1, 2, 5, 3, 4 ] )    // 输出：5
```
2. call和apply的用途

- 改变this指向
call和apply最常见的用途是改变函数内部的this指向

```js
  const obj1 = {
      name: 'sven'
  };

  const obj2 = {
      name: 'anne'
  };

  window.name = 'window';

  const getName = function(){
      alert ( this.name );
  };

  getName();    // 输出： window
  getName.call( obj1 );    // 输出： sven
  getName.call( obj2 );    // 输出： anne
  // 当执行getName.call( obj1 )这句代码时，getName函数体内的this就指向obj1对象
```

- Function.prototype.bind

**模拟bind**

```js
Function.prototype.bind = function(context){
  return ()=>{
    return this.apply(context,arguments)
  }
}

const obj = {
  name:'sven'
}
const func = function(){
  console.log(this.name)
}.bind(obj)

func()
```
> 在Function.prototype.bind的内部实现中，我们先把func函数的引用保存起来，然后返回一个新的函数。当我们在将来执行func函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply( context, arguments )这句代码才是执行原来的func函数，并且指定context对象为func函数体内的this。

**复杂版**

```js
Function.prototype.bind = function(){
  const self = this,
  context = [].shift.call( arguments ), //需要绑定的this上下文
  args = [].slice.call( arguments ); //剩余参数转换成数组
  // console.log(arguments,'==args')
  return function(){
      //执行新的函数的时候，会把之前传入的context当作新函数体内的this,并且组合两次分别传入的参数，作为新函数的参数
      return self.apply( context, [].concat.call( args, [].slice.call( arguments ) ) );
  }
}
const obj = {
name:'sven'
}

const func = function( a, b, c, d ){
  console.log ( this.name );        // 输出：sven
  console.log ( [ a, b, c, d ] )    // 输出：[ 1, 2, 3, 4 ]
}.bind( obj, 1, 2 );

func(3,4)

```
- 借用其他对象的方法

(1)借用构造函数

```js
  const A = function( name ){
      this.name = name;
  };

  const B = function(){
      A.apply( this, arguments );
  };

  B.prototype.getName = function(){
      return this.name;
  };

  const b = new B( 'sven' );
  console.log( b.getName() );  // 输出： 'sven'
```
(2)函数的参数列表arguments是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。

这种情况下，我们常常会借用Array.prototype对象上的方法。比如想往arguments中添加一个新的元素，通常会借用Array.prototype.push：

```js
  (function(){
      Array.prototype.push.call( arguments, 3 );
      console.log ( arguments );    // 输出[1,2,3]
  })( 1, 2 );
```
> 想把arguments转成真正的数组的时候，可以借用Array.prototype.slice方法；想截去arguments列表中的头一个元素时，又可以借用Array.prototype.shift方法

借用Array.prototype.push方法的对象还要满足以下两个条件

  (1)对象本身要可以存取属性；

  (2)对象的length属性可读写。

如果借用Array.prototype.push方法的不是一个object类型的数据，而是一个number类型的数据呢？我们无法在number身上存取其他数据

```js
  const a = 1;
  Array.prototype.push.call( a, 'first' );
  alert ( a.length );      // 输出：undefined
  alert ( a[ 0 ] );    // 输出：undefined
```
函数的length属性就是一个只读的属性，表示形参的个数，我们尝试把一个函数当作this传入Array.prototype.push：

```js
const func = function(){};
Array.prototype.push.call( func, 'first' );

alert ( func.length );
// 报错：cannot assign to read only property ‘length' of function(){}
```
## 第3章 闭包和高阶函数

https://www.cnblogs.com/sallet/p/4002242.html

### 1.闭包

#### 变量的作用域
变量的作用域，就是指变量的有效范围

当在函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量，
如果用var关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。

随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的

```js
const a = 1;

const func1 = function(){
  const b = 2;
    const func2 = function(){
      const c = 3;
      console.log ( b );     // 输出：2
      console.log  ( a );     // 输出：1
    }
    func2();
    console.log  ( c );    // 输出：Uncaught ReferenceError: c is not defined
};

func1();
```
#### 变量的生存周期

- 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。
- 而对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁：

```js
  const func = function(){
      let a = 1;
      return function(){
        a++;
        alert ( a );
      }
  };
  const f = func();
  f();    // 输出：2
  f();    // 输出：3
  f();    // 输出：4
  f();    // 输出：5

```
当退出函数后，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行var f = func()；时，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了

### 2.高阶函数

见前端基础高阶函数
### 3.小结





       
