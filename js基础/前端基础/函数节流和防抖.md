# 函数节流和防抖

防抖和节流是两种应对web页面中频繁触发事件的优化方案。

开发过程中，如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。

## 1. 函数节流 （throttle）

使用场景：
- window.onresize事件
- mousemove事件
- 上传进度
- 拖拽

共同问题：函数被触发的频率太高。

函数节流的原理：

- 设定一个延迟周期；
- 触发事件后等待一个周期在执行；
- 若期间再次触发事件，不执行；
- 等待周期结束后，在执行；

将即将被执行的函数用setTimeout延迟一段时间执行。如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。throttle函数接受2个参数，第一个参数为需要被延迟执行的函数，第二个参数为延迟执行的时间

```js
const throttle = (fn, interval)=> {
  let timer = null,
  firstTime = false
  return (...args)=>{
    if(firstTime){  //如果是第一次调用不延迟执行
      fn(...args)
      return firstTime = false
    }
    if(timer){  //如果定时器还在，说明前一次延迟执行还没完成
      return false
    }
    timer = setTimeout(() => {
        clearTimeout(timer);
        timer = null;
        fn(...args)
    }, interval || 500);
  }
}

```

## 2. 函数防抖 （debounce）

使用场景：

- 点击按钮事件，用户在一定时间段内的点击事件，为了防止和服务端的多次交互，我们可以采用防抖。
- 输入框的自动保存事件
- 浏览器的resize事件

函数防抖的原理：
  - 设定一个延迟周期；
  - 触发事件后，等待一个周期在执行；
  - 如果期间又被触发，则重新计算周期；
  - 直到周期结束，执行动作；

防抖可以概括为触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。

