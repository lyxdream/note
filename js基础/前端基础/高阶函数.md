# 高阶函数

高阶函数是指至少满足下列条件之一的函数。
- 函数可以作为参数被传递；
- 函数可以作为返回值输出。

## 函数作为参数传递

1. 回调函数

- 当我们想在ajax请求返回之后做一些事情，但又并不知道请求返回的确切时间时，最常见的方案就是把callback函数当作参数传入发起ajax请求的方法中，待请求完成之后执行callback函数：

```js
const getUserInfo = function( userId, callback ){
    $.ajax( 'http://xxx.com/getUserInfo? ' + userId, function( data ){
      if ( typeof callback === 'function' ){
          callback( data );
      }
    });
}

getUserInfo( 13157, function( data ){
    alert ( data.userName );
});
```
- 回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，我们也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，“委托”给另外一个函数来执行。

我们想在页面中创建100个div节点，然后把这些div节点都设置为隐藏

```js
  const appendDiv = function(){
      for ( let i = 0; i < 100; i++ ){
        const div = document.createElement( 'div' );
        div.innerHTML = i;
        document.body.appendChild( div );
        div.style.display = 'none';
      }
  };
  appendDiv();

```
我们把div.style.display = 'none’这行代码抽出来，用回调函数的形式传入appendDiv方法：

```js
const appendDiv = function( callback ){
   for ( let i = 0; i < 100; i++ ){
      const div = document.createElement( 'div' );
      div.innerHTML = i;
      document.body.appendChild( div );
      if ( typeof callback === 'function' ){
          callback( div );
      }
  }
};

appendDiv(function( node ){
  node.style.display = 'none';
});

```
可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好
于是把隐藏节点的逻辑放在回调函数中，“委托”给appendDiv方法,节点创建好的时候，appendDiv会执行之前客户传入的回调函数。

2. Array.prototype.sort

Array.prototype.sort接受一个函数当作参数，这个函数里面封装了数组元素的排序规则。
从Array.prototype.sort的使用可以看到，我们的目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分
把可变的部分封装在函数参数里，动态传入Array.prototype.sort

```js
//从小到大排列
[ 1, 4, 3 ].sort( function( a, b ){
    return a - b;
});
// 输出： [ 1, 3, 4 ]

//从大到小排列
[ 1, 4, 3 ].sort( function( a, b ){
    return b - a;
});
// 输出： [ 4, 3, 1 ]
```

## 函数作为返回值输出

> 让函数继续返回一个可执行的函数

1. 判断数据的类型

Object.prototype.toString.call( obj )来判断数据类型。为了避免多余的代码，我们尝试把这些字符串作为参数提前值入isType函数。

```js
const isType = function( type ){
    return function( obj ){
      return Object.prototype.toString.call( obj ) === '[object '+ type +']';
    }
};
const isString = isType( 'String' );
const isArray = isType( 'Array' );
const isNumber = isType( 'Number' );

console.log( isArray( [ 1, 2, 3 ] ) );     // 输出：true
```

我们还可以用循环语句，来批量注册这些isType函数：

```js
const Type = {};
for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; ){
    (function( type ){
      Type[ 'is' + type ] = function( obj ){
          return Object.prototype.toString.call( obj ) === '[object '+ type +']';
          }
      })( type )
};
 
/**
 * {
  isString: [Function (anonymous)],
  isArray: [Function (anonymous)],
  isNumber: [Function (anonymous)]
}
**/
Type.isArray( [] );     // 输出：true
Type.isString( "str" )    // 输出：true
```
2. getSingle

```js

const getSingle = function ( fn ) {
    const ret;
    return function () {
      return ret || ( ret = fn.apply( this, arguments ) );
    };
};
const getScript = getSingle(function(){
    return document.createElement( 'script' );
});

const script1 = getScript();
const script2 = getScript();
alert ( script1 === script2 );    // 输出：true
```
这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数。

## 高阶函数实现AOP

AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来,这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等
把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。

在JavaScript中实现AOP，都是指把一个函数“动态织入”到另外一个函数之中

优点：首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。

- before函数

> 给某个方法添加一个方法在它执行之前调用

```js
let func = function(a){
  console.log( a+2 );
};
```
```js
// es5
Function.prototype.before = function( beforefn ){
  const __self = this;    // 保存原函数的引用
  return function(){    // 返回包含了原函数和新函数的"代理"函数
    beforefn.apply( this, arguments );     // 执行新函数，修正this
    return __self.apply( this, arguments );    // 执行原函数
  }
};
func = func.before(function (b) {
  console.log(b) //3
  console.log('before say')
})
func(3) 
/**
 * 3
 * before say
   5
 */
```

```js
// es6
Function.prototype.before = function (beforefn) {
  return (...args) => {
      //箭头函数改变this指向func()  //箭头函数没有this也没有argument
     beforefn(...args);
     return this(...args)  // console.log(this)  [Function: say]
  }
}
func = func.before(function (b) {
  console.log(b) //3
  console.log('before say')
})
func(3)
/**
 * 3
 * before say
   5
 */
```
- after函数

```js
let func = function(a){
  console.log( a+2 ); 
};
```

```js
//es5版本
Function.prototype.after = function(afterfn){
  const __self = this
  return function(){
    const ret = __self.apply(this,arguments);
    afterfn()
    return ret
  }
}
func = func.after(function(){
  console.log( 3 ); //3
})
func(5) 
/**
 * 7
   3
 */
```

```js
// es6版本
Function.prototype.after = function(afterfn){
  return (...args)=>{
    const ret = this(...args)
    afterfn()
    return ret
  }
}
func = func.after(function(){
  console.log( 3 ); //3
})
func(5) 
/**
 * 7
   3
 */
```

同时使用before和after函数

```js
let func = function(a){
  console.log( a+2 ); //7
};
Function.prototype.before = function (beforefn) {
  return (...args) => {
      //箭头函数改变this指向func()  //箭头函数没有this也没有argument
     beforefn(...args);
     return this(...args)  // console.log(this)  [Function: say]
  }
}
Function.prototype.after = function(afterfn){
  return (...args)=>{
    const ret = this(...args)
    afterfn()
    return ret
  }
}
func = func.before(function(){
  console.log( 1 );
}).after(function(){
  console.log( 3 );
});
func(5)
/**
  1
  7
  3
 */

```
## 高阶函数的其他应用

1. currying

函数柯里化（function currying）

> currying又称部分求值。一个currying的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。

> 柯里化是将使用多个参数的一个函数，通过拆分参数的方式，转换成一系列使用一个参数的函数。

es5的几种实现方式：

(1)第一种
```js
var currying = function(fn){
  var args = []
  var len = fn.length;
  return function(){
    // Array.prototype.push.apply( args, arguments );    // args借用Array.prototype.push方法
    [].push.apply(args,arguments ) //args借用[]的push方法
    if(args.length<len){
      return arguments.callee
    }else{
      return fn.apply(this,args)
    }
  }
}
```
(2)第二种

```js
var currying = function(fn){
  const args = []
  return function(){
    if(arguments.length==0){
      return fn.apply(this,args)
    }else{
      [].push.apply(args,arguments)
      return arguments.callee
    }
  }
}
```
(3)第三种

```js
function currying(fn, args) {
  var args = args || [];//用来存储所有传入的参数
  var _this = this;
  var len = fn.length;
  return function () {
      var _args = Array.prototype.slice.call(arguments) //把arguments转换成数组  用来存放每次递归传过来的参数
       _args = args.concat(_args)
      // 如果参数个数小于fn.length，则递归调用，继续收集参数
      if (_args.length < len) {
          return currying.call(_this, fn, _args)
      } else {
          // 参数收集完毕，则执行fn
          return fn.apply(_this, _args)
      }
  }
}
```
使用示例：

```js
 function isType(type, value) {
  return Object.prototype.toString.call(value) === `[object ${type}]`
}
var isArray = currying(isType)('Array');
// (1)(3)两种使用方式
console.log(isArray([])) //true
// (2)使用方式
console.log(isArray([])())//true
```

```js
var cost = (function(){
  var money = 0;
  return function(){
    for ( var i = 0, l = arguments.length; i < l; i++ ){
        money += arguments[ i ];
    }
    return money;
  }
})();

var costFn = currying( cost );    // 转化成currying函数

// (1)(3)两种使用方式
currying( cost )(100)(200)(300);    // 600

//(2)使用方式
costFn( 100 );    // 未真正求值
costFn( 200 );    // 未真正求值
costFn( 300 );    // 未真正求值
console.log ( costFn() );     // 求值并输出：600
// 或者
currying( cost )(100)(200)(300)();    // 600


```

function currying(){}接受一个参数，即将要被currying的函数。

当调用cost()时，如果明确地带上了一些参数，表示此时并不进行真正的求值计算，而是把这些参数保存起来，此时让cost函数返回另外一个函数。只有当我们以不带参数的形式执行cost()时，才利用前面保存的所有参数，真正开始进行求值计算。


2. uncurrying

当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为拥有这个方法，这是动态类型语言的特点，也是常说的鸭子类型思想

**我们常常让类数组对象去借用Array.prototype的方法**，这是call和apply最常见的应用场景之一：

```js
  (function(){
      Array.prototype.push.call( arguments, 4 );    // arguments借用Array.prototype.push方法
      console.log( arguments );      // 输出：[1, 2, 3, 4]
  })( 1, 2, 3 );
```

以下代码是uncurrying的实现方式之一

```js
Function.prototype.uncurrying = function () {
    const self = this;
    return function() {
      const obj = Array.prototype.shift.call( arguments );
      return self.apply( obj, arguments );  //改变this的指向
  };
};
```

```js
  let push = Array.prototype.push.uncurrying();
  (function(){
      push( arguments, 4 );
      console.log( arguments );     // 输出：[1, 2, 3, 4]
  })( 1, 2, 3 );

```
> 通过uncurrying的方式，Array.prototype.push.call变成了一个**通用的push函数**。


**案例**

把Array.prototype上的方法“复制”到array对象上

```js
  for ( var i = 0, fn, ary = [ 'push', 'shift', 'forEach' ]; fn = ary[ i++ ]; ){
      Array[ fn ] = Array.prototype[ fn ].uncurrying();
  };

  var obj = {
      "length": 3,
      "0": 1,
      "1": 2,
      "2": 3
  };

  Array.push( obj, 4 );     // 向对象中添加一个元素
  console.log( obj.length );    // 输出：4

  var first = Array.shift( obj );    // 截取第一个元素
  console.log( first );     // 输出：1
  console.log( obj );    // 输出：{0: 2, 1: 3, 2: 4, length: 3}

  Array.forEach( obj, function( i, n ){
      console.log( n );      // 分别输出：0, 1, 2
  });

```