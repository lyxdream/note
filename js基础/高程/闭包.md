# 闭包

要了解闭包需要先了解以下几个知识点：

1. this对象
2. 执行上下文
3. 作用域
4. 垃圾回收机制（内存泄漏）


## 定义：

比较常见的闭包是指在函数外部可以访问函数内部变量的函数，因为一般情况下在函数外部是没法访问函数内部的变量的。比如说定义一个函数fn1，如果在函数fn1的内部再定义一个函数fn2，fn2是能访问到fn1的变量的，然后再把fn2 return出去，fn1外部就可以通过fn2访问fn1的变量了；

- 内部函数实用了外部函数的变量
- 外部函数已经退出
- 内部函数可以访问

```js
function fn1（）{
	const a = 1
	function fn2(){
    console.log(a)
  }
  return fn2
}
const fn = fn1()//fn=>fn2
fn()//1
```

> 函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。

## 为什么fn2是能访问到fn1的变量的？

在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。

因此，在createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。如下图展示了以下代码执行后的结果。

![闭包](./../../static/closure/8.png)

> 在 createComparisonFunction()返回匿名函数后，它的作用域链被初始化为包含 createComparisonFunction()的活动对象和全局变量对象。这样，匿名函数就可以访问到 createComparisonFunction()可以访问的所有变量。另一个有意思的副作用就是，createComparisonFunction()的活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在 createComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留在内存中，直到匿名函数被销毁后才会被销毁：

## 如何释放内存

匿名函数被销毁后才会被销毁

```js
// 创建比较函数
let compareNames = createComparisonFunction('name'); 
// 调用函数
let result = compareNames({ name: 'Nicholas' }, { name: 'Matt' }); 
// 解除对函数的引用，这样就可以释放内存了
compareNames = null; 
```

这里，创建的比较函数被保存在变量 compareNames 中。把 compareNames 设置为等于 null 会解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全局作用域之外）也可以销毁。


