1. js的instanceof用法

instanceof 是 JavaScript 的一个运算符，用于检查一个对象是否是某个特定类的实例。

语法如下：

```js
object instanceof class
```
其中，object 是要检查的对象，class 是要检查的类或构造函数。

使用 instanceof 运算符可以判断一个对象是否是某个类的实例，或者是该类的派生类的实例。它会返回一个布尔值，表示对象是否是指定类或其派生类的实例。

下面是一个使用 instanceof 的示例：

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
}

class Dog extends Animal {
  bark() {
    console.log("Woof!");
  }
}

let animal = new Animal("Animal");
let dog = new Dog("Dog");

console.log(animal instanceof Animal); // true
console.log(animal instanceof Dog);    // false
console.log(dog instanceof Animal);    // true
console.log(dog instanceof Dog);       // true
```

在上面的示例中，我们定义了一个 Animal 类和一个继承自 Animal 的 Dog 类。然后创建了一个 Animal 对象和一个 Dog 对象。通过使用 instanceof 运算符，我们可以得出以下结论：

animal instanceof Animal 返回 true，因为 animal 是 Animal 的实例。
animal instanceof Dog 返回 false，因为 animal 不是 Dog 的实例，而是 Animal 的实例。
dog instanceof Animal 返回 true，因为 dog 是 Animal 的实例，同时也是 Dog 的实例。
dog instanceof Dog 返回 true，因为 dog 是 Dog 的实例。
总结起来，instanceof 运算符可以用来判断一个对象是否是某个类的实例或其派生类的实例，从而进行类型检查或判断对象的继承关系。


2. Object.create的实现原理

Object.create() 是 JavaScript 中用于创建一个新对象的方法。它的实现原理可以简单地描述为：

- 创建一个空的构造函数（ObjectCreate）。
- 将传入的原型对象作为 ObjectCreate 的原型。
- 返回通过 new ObjectCreate() 创建的新对象。

下面是一个实现 Object.create() 的示例代码：

```js
function createObject(proto) {
  function ObjectCreate() {}
  ObjectCreate.prototype = proto;
  return new ObjectCreate();
}
// 使用示例
var obj = createObject({ foo: 'bar' });
console.log(obj.foo); // 输出 'bar'
```
在这个示例中，createObject 函数接受一个原型对象作为参数，然后创建一个空的构造函数 ObjectCreate。接下来，将原型对象赋值给 ObjectCreate 的原型属性。最后，通过使用 new ObjectCreate() 创建一个新对象，并将其返回。

请注意，这只是 Object.create() 的一种简化实现方式，实际的规范中还会考虑到更多的细节和边界情况。但是这个简化版本可以帮助你理解 Object.create() 的大致实现原理。


在不支持Object.create方法的浏览器中，则可以使用以下代码：
```js
  Object.create = Object.create || function( obj ){
      const F = function(){};
      F.prototype = obj;

      return new F();
  }
```

> 通过设置构造器的prototype来实现原型继承的时候，除了根对象Object.prototype本身之外，任何对象都会有一个原型。而通过Object.create( null )可以创建出没有原型的对象。

3. Object.getPrototypeOf

Object.getPrototypeOf是一个JavaScript内置方法，它用于获取指定对象的原型（即原型链中的上一级）。以下是它的用法：

语法：Object.getPrototypeOf(obj)

obj：要获取原型的对象。

```js
const obj = {};
const proto = { foo: 'bar' };

Object.setPrototypeOf(obj, proto);

const prototype = Object.getPrototypeOf(obj);
console.log(prototype); // 输出: { foo: 'bar' }


```

Object.getPrototypeOf方法只能获取第一个原型，无法获取整个原型链。
如果要获取完整的原型链，可以使用递归或循环来遍历对象的原型，直到获取到Object.prototype为止

```js
function getPrototypeChain(obj) {
  const prototypes = [];
  let prototype = Object.getPrototypeOf(obj);

  while (prototype !== null) {
    prototypes.push(prototype);
    prototype = Object.getPrototypeOf(prototype);
  }

  return prototypes;
}

const obj = {};
const proto1 = { foo: 'bar' };
const proto2 = { baz: 'qux' };

Object.setPrototypeOf(obj, proto1);
Object.setPrototypeOf(proto1, proto2);

const prototypeChain = getPrototypeChain(obj);
console.log(prototypeChain); // 输出: [ { baz: 'qux' }, { foo: 'bar' }, {} ]

//Object.setPrototypeOf方法将obj的原型设置为proto1。
```

在上面的示例中，我们定义了一个getPrototypeChain函数，它接受一个对象obj作为参数，并使用循环不断获取obj及其原型的原型，直到原型为null。然后，将原型对象存储在prototypes数组中，并返回该数组。最后，我们通过console.log打印出完整的原型链，输出结果为[{ baz: 'qux' }, { foo: 'bar' }, {}]。

4. new的过程

- 创建一个空对象
- 使该对象proto指向构造函数的原型对象
- 使用构造函数为其初始化属性（将构造函数的this指向新对象）
- 返回这个对象

```js
const objectFactory = function(){
  const obj = new Object();
  Constructor = [].shift.call(arguments)
  obj.__proto__ = Constructor.prototype
  const ret = Constructor.apply( obj, arguments );    // 借用外部传入的构造器给obj设置属性
  return typeof ret === 'object' ? ret : obj;     // 确保构造器总是会返回一个对象
}
  function Person( name ){
      this.name = name;
  };

  Person.prototype.getName = function(){
      return this.name;
  };
const a = objectFactory( Person, 'sven' );
  console.log( a.name );    // 输出：sven
  console.log( a.getName() );     // 输出：sven
  console.log( Object.getPrototypeOf( a ) === Person.prototype );      // 输出：true
```
5. this
JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。

this的指向大致可以分为以下4种。
 - 作为对象的方法调用。
 - 作为普通函数调用。
 - 构造器调用。
 - Function.prototype.call或Function.prototype.apply调用。

1．作为对象的方法调用
当函数作为对象的方法被调用时，this指向该对象：

```js
  const obj = {
      a: 1,
      getA: function(){
        alert ( this === obj );    // 输出：true
        alert ( this.a );    // 输出： 1
      }
  };
  obj.getA();
```
2．作为普通函数调用

此时的this总是指向全局对象。在浏览器的JavaScript里，这个全局对象是window对象。
```js
  window.name = 'globalName';
  const getName = function(){
      return this.name;
  };
  console.log( getName() );    // 输出：globalName
```

<!-- 或者 -->

```js
  window.name = 'globalName';

  const myObject = {
      name: 'sven',
      getName: function(){
        return this.name;
      }
  };

  const getName = myObject.getName;
  console.log( getName() );    // globalName
```

3．构造器调用
构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。
> 当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象

```js
const MyClass = function(){
    this.name = 'sven';
};
const obj = new MyClass();
alert ( obj.name );     // 输出：sven
```
> 但用new调用构造器时，还要注意一个问题，如果构造器显式地返回了一个object类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this：

```js
const MyClass = function(){
  this.name = 'sven'
  return {
    name:"anne"
  }
}
const obj = new MyClass();
console.log(obj.name)  //anne
```
> 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题：
```js
const MyClass = function(){
  this.name = 'sven'
  return "anne"
}
const obj = new MyClass();
console.log(obj.name)  //sven
```
4. Function.prototype.call或Function.prototype.apply调用

> 跟普通的函数调用相比，用Function.prototype.call或Function.prototype.apply可以动态地改变传入函数的this：

```js
  const obj1 = {
      name: 'sven',
      getName: function(){
        return this.name;
      }
  };

  const obj2 = {
      name: 'anne'
  };

  console.log( obj1.getName() );     // 输出： sven
  console.log( obj1.getName.call( obj2 ) );    // 输出：anne
```

6. call和apply

