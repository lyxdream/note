1. js的instanceof用法

instanceof 是 JavaScript 的一个运算符，用于检查一个对象是否是某个特定类的实例。

语法如下：

```js
object instanceof class
```
其中，object 是要检查的对象，class 是要检查的类或构造函数。

使用 instanceof 运算符可以判断一个对象是否是某个类的实例，或者是该类的派生类的实例。它会返回一个布尔值，表示对象是否是指定类或其派生类的实例。

下面是一个使用 instanceof 的示例：

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
}

class Dog extends Animal {
  bark() {
    console.log("Woof!");
  }
}

let animal = new Animal("Animal");
let dog = new Dog("Dog");

console.log(animal instanceof Animal); // true
console.log(animal instanceof Dog);    // false
console.log(dog instanceof Animal);    // true
console.log(dog instanceof Dog);       // true
```

在上面的示例中，我们定义了一个 Animal 类和一个继承自 Animal 的 Dog 类。然后创建了一个 Animal 对象和一个 Dog 对象。通过使用 instanceof 运算符，我们可以得出以下结论：

animal instanceof Animal 返回 true，因为 animal 是 Animal 的实例。
animal instanceof Dog 返回 false，因为 animal 不是 Dog 的实例，而是 Animal 的实例。
dog instanceof Animal 返回 true，因为 dog 是 Animal 的实例，同时也是 Dog 的实例。
dog instanceof Dog 返回 true，因为 dog 是 Dog 的实例。
总结起来，instanceof 运算符可以用来判断一个对象是否是某个类的实例或其派生类的实例，从而进行类型检查或判断对象的继承关系。


2. Object.create的实现原理

Object.create() 是 JavaScript 中用于创建一个新对象的方法。它的实现原理可以简单地描述为：

- 创建一个空的构造函数（ObjectCreate）。
- 将传入的原型对象作为 ObjectCreate 的原型。
- 返回通过 new ObjectCreate() 创建的新对象。

下面是一个实现 Object.create() 的示例代码：

```js
function createObject(proto) {
  function ObjectCreate() {}
  ObjectCreate.prototype = proto;
  return new ObjectCreate();
}
// 使用示例
var obj = createObject({ foo: 'bar' });
console.log(obj.foo); // 输出 'bar'
```
在这个示例中，createObject 函数接受一个原型对象作为参数，然后创建一个空的构造函数 ObjectCreate。接下来，将原型对象赋值给 ObjectCreate 的原型属性。最后，通过使用 new ObjectCreate() 创建一个新对象，并将其返回。

请注意，这只是 Object.create() 的一种简化实现方式，实际的规范中还会考虑到更多的细节和边界情况。但是这个简化版本可以帮助你理解 Object.create() 的大致实现原理。


在不支持Object.create方法的浏览器中，则可以使用以下代码：
```js
  Object.create = Object.create || function( obj ){
      const F = function(){};
      F.prototype = obj;

      return new F();
  }
```

3. Object.getPrototypeOf

Object.getPrototypeOf是一个JavaScript内置方法，它用于获取指定对象的原型（即原型链中的上一级）。以下是它的用法：

语法：Object.getPrototypeOf(obj)

obj：要获取原型的对象。

```js
const obj = {};
const proto = { foo: 'bar' };

Object.setPrototypeOf(obj, proto);

const prototype = Object.getPrototypeOf(obj);
console.log(prototype); // 输出: { foo: 'bar' }


```

Object.getPrototypeOf方法只能获取第一个原型，无法获取整个原型链。
如果要获取完整的原型链，可以使用递归或循环来遍历对象的原型，直到获取到Object.prototype为止

```js
function getPrototypeChain(obj) {
  const prototypes = [];
  let prototype = Object.getPrototypeOf(obj);

  while (prototype !== null) {
    prototypes.push(prototype);
    prototype = Object.getPrototypeOf(prototype);
  }

  return prototypes;
}

const obj = {};
const proto1 = { foo: 'bar' };
const proto2 = { baz: 'qux' };

Object.setPrototypeOf(obj, proto1);
Object.setPrototypeOf(proto1, proto2);

const prototypeChain = getPrototypeChain(obj);
console.log(prototypeChain); // 输出: [ { baz: 'qux' }, { foo: 'bar' }, {} ]

//Object.setPrototypeOf方法将obj的原型设置为proto1。
```

在上面的示例中，我们定义了一个getPrototypeChain函数，它接受一个对象obj作为参数，并使用循环不断获取obj及其原型的原型，直到原型为null。然后，将原型对象存储在prototypes数组中，并返回该数组。最后，我们通过console.log打印出完整的原型链，输出结果为[{ baz: 'qux' }, { foo: 'bar' }, {}]。

4. new的过程

- 创建一个空对象
- 使该对象proto指向构造函数的原型对象
- 使用构造函数为其初始化属性（将构造函数的this指向新对象）
- 返回这个对象

```js
const objectFactory = function(){
  const obj = new Object();
  Constructor = [].shift.call(arguments)
  obj.__proto__ = Constructor.prototype
  const ret = Constructor.apply( obj, arguments );    // 借用外部传入的构造器给obj设置属性
  return typeof ret === 'object' ? ret : obj;     // 确保构造器总是会返回一个对象
}
  function Person( name ){
      this.name = name;
  };

  Person.prototype.getName = function(){
      return this.name;
  };
const a = objectFactory( Person, 'sven' );
  console.log( a.name );    // 输出：sven
  console.log( a.getName() );     // 输出：sven
  console.log( Object.getPrototypeOf( a ) === Person.prototype );      // 输出：true
```




```js
  function Person( name ){
      this.name = name;
  };

  Person.prototype.getName = function(){
      return this.name;
  };

  var objectFactory = function(){
      var obj = new Object(),    // 从Object.prototype上克隆一个空的对象
        Constructor = [].shift.call( arguments );    // 取得外部传入的构造器，此例是Person
       obj.__proto__ = Constructor.prototype;    // 指向正确的原型
      var ret = Constructor.apply( obj, arguments );    // 借用外部传入的构造器给obj设置属性

      return typeof ret === 'object' ? ret : obj;     // 确保构造器总是会返回一个对象
  };

  var a = objectFactory( Person, 'sven' );
  console.log( a.name );    // 输出：sven
  console.log( a.getName() );     // 输出：sven
  console.log( Object.getPrototypeOf( a ) === Person.prototype );      // 输出：true

```

