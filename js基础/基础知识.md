1. js的instanceof用法

instanceof 是 JavaScript 的一个运算符，用于检查一个对象是否是某个特定类的实例。

语法如下：

```js
object instanceof class
```
其中，object 是要检查的对象，class 是要检查的类或构造函数。

使用 instanceof 运算符可以判断一个对象是否是某个类的实例，或者是该类的派生类的实例。它会返回一个布尔值，表示对象是否是指定类或其派生类的实例。

下面是一个使用 instanceof 的示例：

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
}

class Dog extends Animal {
  bark() {
    console.log("Woof!");
  }
}

let animal = new Animal("Animal");
let dog = new Dog("Dog");

console.log(animal instanceof Animal); // true
console.log(animal instanceof Dog);    // false
console.log(dog instanceof Animal);    // true
console.log(dog instanceof Dog);       // true
```

在上面的示例中，我们定义了一个 Animal 类和一个继承自 Animal 的 Dog 类。然后创建了一个 Animal 对象和一个 Dog 对象。通过使用 instanceof 运算符，我们可以得出以下结论：

animal instanceof Animal 返回 true，因为 animal 是 Animal 的实例。
animal instanceof Dog 返回 false，因为 animal 不是 Dog 的实例，而是 Animal 的实例。
dog instanceof Animal 返回 true，因为 dog 是 Animal 的实例，同时也是 Dog 的实例。
dog instanceof Dog 返回 true，因为 dog 是 Dog 的实例。
总结起来，instanceof 运算符可以用来判断一个对象是否是某个类的实例或其派生类的实例，从而进行类型检查或判断对象的继承关系。


2. Object.create的实现原理

Object.create() 是 JavaScript 中用于创建一个新对象的方法。它的实现原理可以简单地描述为：

- 创建一个空的构造函数（ObjectCreate）。
- 将传入的原型对象作为 ObjectCreate 的原型。
- 返回通过 new ObjectCreate() 创建的新对象。

下面是一个实现 Object.create() 的示例代码：

```js
function createObject(proto) {
  function ObjectCreate() {}
  ObjectCreate.prototype = proto;
  return new ObjectCreate();
}
// 使用示例
var obj = createObject({ foo: 'bar' });
console.log(obj.foo); // 输出 'bar'
```
在这个示例中，createObject 函数接受一个原型对象作为参数，然后创建一个空的构造函数 ObjectCreate。接下来，将原型对象赋值给 ObjectCreate 的原型属性。最后，通过使用 new ObjectCreate() 创建一个新对象，并将其返回。

请注意，这只是 Object.create() 的一种简化实现方式，实际的规范中还会考虑到更多的细节和边界情况。但是这个简化版本可以帮助你理解 Object.create() 的大致实现原理。


在不支持Object.create方法的浏览器中，则可以使用以下代码：
```js
  Object.create = Object.create || function( obj ){
      const F = function(){};
      F.prototype = obj;

      return new F();
  }
```

> 通过设置构造器的prototype来实现原型继承的时候，除了根对象Object.prototype本身之外，任何对象都会有一个原型。而通过Object.create( null )可以创建出没有原型的对象。

3. Object.getPrototypeOf

Object.getPrototypeOf是一个JavaScript内置方法，它用于获取指定对象的原型（即原型链中的上一级）。以下是它的用法：

语法：Object.getPrototypeOf(obj)

obj：要获取原型的对象。

```js
const obj = {};
const proto = { foo: 'bar' };

Object.setPrototypeOf(obj, proto);

const prototype = Object.getPrototypeOf(obj);
console.log(prototype); // 输出: { foo: 'bar' }


```

Object.getPrototypeOf方法只能获取第一个原型，无法获取整个原型链。
如果要获取完整的原型链，可以使用递归或循环来遍历对象的原型，直到获取到Object.prototype为止

```js
function getPrototypeChain(obj) {
  const prototypes = [];
  let prototype = Object.getPrototypeOf(obj);

  while (prototype !== null) {
    prototypes.push(prototype);
    prototype = Object.getPrototypeOf(prototype);
  }

  return prototypes;
}

const obj = {};
const proto1 = { foo: 'bar' };
const proto2 = { baz: 'qux' };

Object.setPrototypeOf(obj, proto1);
Object.setPrototypeOf(proto1, proto2);

const prototypeChain = getPrototypeChain(obj);
console.log(prototypeChain); // 输出: [ { baz: 'qux' }, { foo: 'bar' }, {} ]

//Object.setPrototypeOf方法将obj的原型设置为proto1。
```

在上面的示例中，我们定义了一个getPrototypeChain函数，它接受一个对象obj作为参数，并使用循环不断获取obj及其原型的原型，直到原型为null。然后，将原型对象存储在prototypes数组中，并返回该数组。最后，我们通过console.log打印出完整的原型链，输出结果为[{ baz: 'qux' }, { foo: 'bar' }, {}]。

4. new的过程

- 创建一个空对象
- 使该对象proto指向构造函数的原型对象
- 使用构造函数为其初始化属性（将构造函数的this指向新对象）
- 返回这个对象

```js
const objectFactory = function(){
  const obj = new Object();
  Constructor = [].shift.call(arguments)
  obj.__proto__ = Constructor.prototype
  const ret = Constructor.apply( obj, arguments );    // 借用外部传入的构造器给obj设置属性
  return typeof ret === 'object' ? ret : obj;     // 确保构造器总是会返回一个对象
}
  function Person( name ){
      this.name = name;
  };

  Person.prototype.getName = function(){
      return this.name;
  };
const a = objectFactory( Person, 'sven' );
  console.log( a.name );    // 输出：sven
  console.log( a.getName() );     // 输出：sven
  console.log( Object.getPrototypeOf( a ) === Person.prototype );      // 输出：true
```
5. this
JavaScript的this总是指向一个对象，而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。

this的指向大致可以分为以下4种。
 - 作为对象的方法调用。
 - 作为普通函数调用。
 - 构造器调用。
 - Function.prototype.call或Function.prototype.apply调用。

1．作为对象的方法调用
当函数作为对象的方法被调用时，this指向该对象：

```js
  const obj = {
      a: 1,
      getA: function(){
        alert ( this === obj );    // 输出：true
        alert ( this.a );    // 输出： 1
      }
  };
  obj.getA();
```
2．作为普通函数调用

此时的this总是指向全局对象。在浏览器的JavaScript里，这个全局对象是window对象。
```js
  window.name = 'globalName';
  const getName = function(){
      return this.name;
  };
  console.log( getName() );    // 输出：globalName
```

<!-- 或者 -->

```js
  window.name = 'globalName';

  const myObject = {
      name: 'sven',
      getName: function(){
        return this.name;
      }
  };

  const getName = myObject.getName;
  console.log( getName() );    // globalName
```

3．构造器调用
构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。
> 当用new运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的this就指向返回的这个对象

```js
const MyClass = function(){
    this.name = 'sven';
};
const obj = new MyClass();
alert ( obj.name );     // 输出：sven
```
> 但用new调用构造器时，还要注意一个问题，如果构造器显式地返回了一个object类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this：

```js
const MyClass = function(){
  this.name = 'sven'
  return {
    name:"anne"
  }
}
const obj = new MyClass();
console.log(obj.name)  //anne
```
> 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题：
```js
const MyClass = function(){
  this.name = 'sven'
  return "anne"
}
const obj = new MyClass();
console.log(obj.name)  //sven
```
4. Function.prototype.call或Function.prototype.apply调用

> 跟普通的函数调用相比，用Function.prototype.call或Function.prototype.apply可以动态地改变传入函数的this：

```js
  const obj1 = {
      name: 'sven',
      getName: function(){
        return this.name;
      }
  };

  const obj2 = {
      name: 'anne'
  };

  console.log( obj1.getName() );     // 输出： sven
  console.log( obj1.getName.call( obj2 ) );    // 输出：anne
```

6. call和apply


(1)call和apply的区别

> apply接受两个参数，第一个参数指定了函数体内this对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数：
```js
  const func = function( a, b, c ){
      alert ( [ a, b, c ] );    // 输出 [ 1, 2, 3 ]
  };
  func.apply( null, [ 1, 2, 3 ] );
//在这段代码中，参数1、2、3被放在数组中一起传入func函数，它们分别对应func参数列表中的a、b、c。
```
> call传入的参数数量不固定，跟apply相同的是，第一个参数也是代表函数体内的this指向，从第二个参数开始往后，每个参数被依次传入函数：

```js
const func = function( a, b, c ){
    alert ( [ a, b, c ] );    // 输出 [ 1, 2, 3 ]
};
func.call( null, 1, 2, 3 );
```
> 当使用call或者apply的时候，如果我们传入的第一个参数为null，函数体内的this会指向默认的宿主对象，在浏览器中则是window：

有时候我们使用call或者apply的目的不在于指定this指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入null来代替某个具体的对象：

```js
Math.max.apply( null, [ 1, 2, 5, 3, 4 ] )    // 输出：5
```
(2) call和apply的用途

- 改变this指向
call和apply最常见的用途是改变函数内部的this指向

```js
  const obj1 = {
      name: 'sven'
  };

  const obj2 = {
      name: 'anne'
  };

  window.name = 'window';

  const getName = function(){
      alert ( this.name );
  };

  getName();    // 输出： window
  getName.call( obj1 );    // 输出： sven
  getName.call( obj2 );    // 输出： anne
  // 当执行getName.call( obj1 )这句代码时，getName函数体内的this就指向obj1对象
```

- Function.prototype.bind

**模拟bind**

```js
Function.prototype.bind = function(context){
  return ()=>{
    return this.apply(context,arguments)
  }
}

const obj = {
  name:'sven'
}
const func = function(){
  console.log(this.name)
}.bind(obj)

func()
```
> 在Function.prototype.bind的内部实现中，我们先把func函数的引用保存起来，然后返回一个新的函数。当我们在将来执行func函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply( context, arguments )这句代码才是执行原来的func函数，并且指定context对象为func函数体内的this。

**复杂版**

```js
Function.prototype.bind = function(){
  const self = this,
  context = [].shift.call( arguments ), //需要绑定的this上下文
  args = [].slice.call( arguments ); //剩余参数转换成数组
  // console.log(arguments,'==args')
  return function(){
      //执行新的函数的时候，会把之前传入的context当作新函数体内的this,并且组合两次分别传入的参数，作为新函数的参数
      return self.apply( context, [].concat.call( args, [].slice.call( arguments ) ) );
  }
}
const obj = {
name:'sven'
}

const func = function( a, b, c, d ){
  console.log ( this.name );        // 输出：sven
  console.log ( [ a, b, c, d ] )    // 输出：[ 1, 2, 3, 4 ]
}.bind( obj, 1, 2 );

func(3,4)

```
- 借用其他对象的方法

(1)借用构造函数

```js
  const A = function( name ){
      this.name = name;
  };

  const B = function(){
      A.apply( this, arguments );
  };

  B.prototype.getName = function(){
      return this.name;
  };

  const b = new B( 'sven' );
  console.log( b.getName() );  // 输出： 'sven'
```
(2)函数的参数列表arguments是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。

这种情况下，我们常常会借用Array.prototype对象上的方法。比如想往arguments中添加一个新的元素，通常会借用Array.prototype.push：

```js
  (function(){
      Array.prototype.push.call( arguments, 3 );
      console.log ( arguments );    // 输出[1,2,3]
  })( 1, 2 );
```
> 想把arguments转成真正的数组的时候，可以借用Array.prototype.slice方法；想截去arguments列表中的头一个元素时，又可以借用Array.prototype.shift方法

借用Array.prototype.push方法的对象还要满足以下两个条件

  (1)对象本身要可以存取属性；

  (2)对象的length属性可读写。

如果借用Array.prototype.push方法的不是一个object类型的数据，而是一个number类型的数据呢？我们无法在number身上存取其他数据

```js
  const a = 1;
  Array.prototype.push.call( a, 'first' );
  alert ( a.length );      // 输出：undefined
  alert ( a[ 0 ] );    // 输出：undefined
```
函数的length属性就是一个只读的属性，表示形参的个数，我们尝试把一个函数当作this传入Array.prototype.push：

```js
const func = function(){};
Array.prototype.push.call( func, 'first' );

alert ( func.length );
// 报错：cannot assign to read only property ‘length' of function(){}
```